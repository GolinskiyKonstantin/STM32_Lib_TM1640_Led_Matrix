/*

  ******************************************************************************
  * @file 			( фаил ):   TM1640.c
  * @brief 		( описание ):  	
  ******************************************************************************
  * @attention 	( внимание ):
  ******************************************************************************
  
*/

/* Includes ----------------------------------------------------------*/

#include "TM1640.h"

#include "animacion.h"
#include "font.h"


	uint8_t Cmd_DispCtrl = BRIGHTNESS_TM1640;		// контрастность дисплея от 0 -7 
	
	int32_t x = 0; 
	int32_t y = 0;

	uint8_t *frameBuffer = NULL;					// для функции malloc()
/*
	******************************************************************************
	* @brief	 ( описание ):  функция задержки в микросекундах
	* @param	( параметры ):	кол-во микросекунд
	* @return  ( возвращает ):	

	******************************************************************************
*/
void Delay_us( uint32_t i ){
	
	for (; i> 0; i--);
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция для старта ( активации ) передачи данных на модуль
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_Generate_START( void ){
	
	CLK( HIGH );
	DIN( HIGH );
	Delay_us( DELAY_TIME );
	DIN( LOW );
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция для конца отправки данных на модуль ( вызываеться по завершению )
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_Generate_STOP( void ){
	
	CLK( LOW );
	Delay_us( DELAY_TIME );
	DIN( LOW );
	Delay_us( DELAY_TIME );
	CLK( HIGH );
	Delay_us( DELAY_TIME );
	DIN( HIGH );
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция отправки данных на модуль 1 байт
	* @param	( параметры ):	1 байт информации
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_WriteData( uint8_t oneByte ){
	
	Delay_us( DELAY_TIME );
	
	for ( uint8_t i = 0; i < 8; i++ ){
		CLK( LOW );
		
			if( oneByte & ( 1<<i ) ){
				DIN( HIGH );
			}
			else { 
				DIN( LOW ); 
			}
			
		Delay_us( DELAY_TIME );
		CLK( HIGH );
		Delay_us( DELAY_TIME );
	}

	CLK( LOW );
	Delay_us( DELAY_TIME );	
	DIN( LOW );
	while( read_DIN ){};
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция отправляет 1 байт в указаный сегмент
								( 8 пикселей = 8 битам ( 1 байт ) ) где 1 там вкл пиксель и наоборот
	* @param	( параметры ):	1 пар - номер сигмента, 2 пар - 1 байт для отображения
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_display_byte( uint8_t Seg_N, uint8_t DispData ){
	
	TM1640_Generate_START();                                
	TM1640_WriteData( 0x44 );			// 1:фиксированный адресс
	TM1640_Generate_STOP();
	
	TM1640_Generate_START();
	TM1640_WriteData( Seg_N | 0xc0 );	// устанавливаем адресс старшие 2 бита должны быть 1(0xc0)+ номер сегмента
	TM1640_WriteData( DispData );		// отправляем "кодированные" данные для одного сегмента
	TM1640_Generate_STOP();
	
	TM1640_Generate_START();
	TM1640_WriteData( Cmd_DispCtrl );	// включаем дисплей с выставлленой яркостью;
	TM1640_Generate_STOP();
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция включения и выключения экрана с сохранением на нем выведеной информации
	* @param	( параметры ):	байт статуса экрана = 1- вкл, 0- выкл
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_displayOnOff( uint8_t OnOff ){
	
	TM1640_Generate_START();                                
	TM1640_WriteData( 0x44 );		// 1:фиксированный адресс
	TM1640_Generate_STOP();
	
	TM1640_Generate_START();  
	// для включения или выключения дисплея с сохранением текущей контрасности нужно ставить третий бит в 1 вкл 0 выкл	
	TM1640_WriteData( OnOff ? (Cmd_DispCtrl | 1<<3 ) : ( Cmd_DispCtrl & ~( 1<<3 )) );		// 0x80 выкл     0х88 вкл
	TM1640_Generate_STOP();
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция отчистки дисплея
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_clearDisplay( void ){
	
	for( uint8_t i=0; i<16; i++ ){
		TM1640_display_byte( i, 0x00 ); 
	}
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция установки яркости дисплея
	* @param	( параметры ):	яркость дисплея ( значения от 0  до 7 )
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_brightness( uint8_t brightness ){
	
  Cmd_DispCtrl = 0x88 + brightness;
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция преобразования ASCII to UTF-8 для отображения кирилицы
	* @param	( параметры ):	массив ( строка ) с данными которую нужно преобразовать
	* @return  ( возвращает ):	указатель на память где храниться уже преобразованый массив

	******************************************************************************
*/
// функция для кодировки русских символов в UTF-8
char *pText = 0;
// незабываем каждый раз после вызова функции utf8rus() освобождать память
// free( pText );	// освобождаем память выделенную в функции utf8rus() посредством malloc();

char *utf8rus( char *source ){
	
	int i,k;
	k = strlen( (char*)source );
	pText = (char *)malloc( sizeof( k ) );
	
	memset(pText,0,sizeof(*pText));	// отчистка памяти от мусора
	
  unsigned char n;
  char m[2] = { '0', '\0' };

  k = strlen( (char*)source );
  i = 0;

  while (i < k) {
    n = source[i]; i++;

    if (n >= 0xC0) {
			switch (n) {
				case 0xD0: {
					n = source[i]; i++;
					if (n == 0x81) { n = 0xA8; break; }
					if (n >= 0x90 && n <= 0xBF) n = n + 0x30;
					break;
				}
				case 0xD1: {
					n = source[i]; i++;
					if (n == 0x91) { n = 0xB8; break; }
					if (n >= 0x80 && n <= 0x8F) n = n + 0x70;
					break;
				}
			}
		}
		m[0] = n; 
		strcat( pText, m);
	}
	return pText;
} 
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция получения буффера для работы с ним
	* @param	( параметры ):	координата X и Y 
	* @return  ( возвращает ):	указатель на буффер

	******************************************************************************
*/
uint8_t* _getBufferPtr( int8_t x, int8_t y ){
	
	if ( ( y < 0 ) || ( y >= 16 ) ){
		return NULL;
	}
	if ( ( x < 0 ) || ( x >= ( 8 ) ) ){
		return NULL;
	}
	
	uint8_t B = x >> 3;		//byte

	return frameBuffer + y + B;
} 
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция заполнения буффера нужными пикселями
	* @param	( параметры ):	координаты X и Y и ( 0-выкл пиксель, 1-вкл пиксель )
	* @return  ( возвращает ):	

	******************************************************************************
*/
// меняя х у меняем положение текста вертикальное или горизонтальное
void setPixel( int8_t y, int8_t x, uint8_t enabled ){
	
	uint8_t* p = _getBufferPtr( x, y );
	if ( !p ){
		return;
	}
	
	uint8_t b = 7 - ( x & 7 );		//bit

	if ( enabled ){
		*p |=  ( 1<<b );
	}
	else{
		*p &= ~( 1<<b );
	}
} 
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция из массива данных преобразует в пиксели и заполняет буффер
	* @param	( параметры ):	1 пар - ссылка на массив с данными, 2 пар и 3 пар - координаты X Y , 
								3 пар и 4 пар размер фрагмента ( например 8 на 8 пикселей )
	* @return  ( возвращает ):	

	******************************************************************************
*/
void drawSprite( uint8_t* sprite, int x, int y, int width, int height ){
	
  // The mask is used to get the column bit from the sprite row
  uint8_t mask = 0x80;

  for( int iy = 0; iy < height; iy++ ){
    for( int ix = 0; ix < width; ix++ ){
		
      setPixel( x + ix, y + iy, (uint8_t)( sprite[iy] & mask ));

      // shift the mask by one pixel to the right
      mask = mask >> 1;
    }
    // reset column mask
    mask = 0x80;
  }
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция для преобразования полученного символа в его нарисованный вариант в массиве
	* @param	( параметры ):	1 пар - ссылка на текст, 2 пар - длина строки, 3 пар и 4 пар координаты X Y
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_drawString_buff(char* text, int len, int x, int y ){
	
  for( int idx = 0; idx < len; idx ++){
	  
    uint8_t c = text[idx];
	  
	// номер по ASCII - позиция в массиве  = значение которое нужно отнять
	  
	  // символы латинские буквы цифры и спецсимволы начинаються с - 32 символ по ASCII а в массиве 0 эллемент
	  // значит 32 - 0 = 32 значит от текущего значения отнимаем 32
	  // и делаем это для всего латинского алфавита ( так как в массиве он идет по таблице ASCII )
	  // то для всего диапазона ( от 32 до 127 включительно отнимаем 32 )
	  // проверяем диапазон  для латинских символов и немного спец символов 
	  if( c > 31 && c < 128 ){
		  c = c - 32;
	  }
	  
	  // символ кирилица А - 192 символ по ASCII а в массиве 96 эллемент
	  // значит 192 - 96 = 96 значит от текущего значения отнимаем 96
	  // и делаем это для всей килилицы алфавита ( так как в массиве он идет по таблице ASCII )
	  // то для всего диапазона ( от 192 до 255 включительно отнимаем 96 )
	  // проверяем диапазон  для латинских символов и немного спец символов 
	  else  if( c > 191 ){
		  c = c - 96;
	  }
	  
	  // дополнительные символы и знаки если нужны
	  // добавляем в конец массива тут делаем проверку и расчеты
	  // номер по ASCII - позиция в массиве  = значение которое нужно отнять
	  else if( c == 168 ){ c = c - 8; }		    // 168 - 160 эллемент массива ( символ Ё ) = 8
	  else if( c == 184 ){ c = c - 23; }		// 184 - 161 эллемент массива ( символ ё ) = 23
	  
	  
    // stop if char is outside visible area
    if( x + idx * 8  > ( 16 ) )
      return;

    // only draw if char is visible
    if( 8 + x + idx * 8 > 0 )
      drawSprite( disp1ay[c], x + idx* 8, y, 8, 8 );
  }
} 
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция выводит на экран все что нвходиться в буффере
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1640_display_Draw( void ){	

	for (int16_t d = 0; d != 16; d ++){
		
		uint8_t data = frameBuffer[d];

		TM1640_Generate_START();                                
		TM1640_WriteData(0x44);				// 1:фиксированный адресс
		TM1640_Generate_STOP();
		
		TM1640_Generate_START();			  								
		TM1640_WriteData(15-d|0xc0);		// устанавливаем адресс старшие 2 бита должны быть 1(0xc0)+ номер сегмента
		TM1640_WriteData(data);				// отправляем "кодированные" данные для одного сегмента				
		TM1640_Generate_STOP();
		
		TM1640_Generate_START();
		TM1640_WriteData(Cmd_DispCtrl);		// включаем дисплей с выставлленой яркостью;
		TM1640_Generate_STOP();	
	}
}
//----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  функция очистка буффера но не чистит экран
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
void clear_buff( void ){
	
	memset( frameBuffer, 0, 16 );
}
//----------------------------------------------------------------------------------



/************************ (C) COPYRIGHT GKP *****END OF FILE****/
